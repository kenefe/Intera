# 复盘: stateGroups[0] 硬编码事故

> 2026-02-16 · 根因分析 + AI 流程改进

---

## 事故概述

11 个文件、20+ 处代码硬编码 `stateGroups[0]`（主画面），导致：
- 组件 group 内编辑属性 → 写入主画面状态（改基础值而非创建覆盖）
- 组件 group 内拖拽图层 → 写入主画面状态
- Preview 预览 → 只预览主画面
- 曲线编辑 → 只编辑主画面的曲线

**严重度**: P0 — 组件功能完全不可用

---

## 根因分析 (五层追问)

### 1. 为什么组件 group 编辑不生效？

因为 `PropertiesPanel.vue` 的 `isDefaultState` 和 `activeStateId` 硬编码指向 `stateGroups[0]`，
组件 group 的状态被忽略，`set()` 永远走 `updateLayerProps()`。

### 2. 为什么会有 20+ 处硬编码？

初始实现只有一个 group（主画面），`stateGroups[0]` 就是"当前 group"。
多 group 支持在渲染层（ArtboardGrid、StateBar）引入后，编辑层未同步迁移。
**这是经典的「半迁移」—— 新概念在 UI 层落地，逻辑层遗漏。**

### 3. 为什么半迁移没被代码审查发现？

`activeGroupId` 和 `setActiveGroup` 的添加是作为 ArtboardGrid/StateBar 的局部改动引入的。
审查范围限于改动文件，未全局搜索 `stateGroups[0]` 来识别受影响的消费者。

### 4. 为什么 AI 旅程验证没发现？

**最核心的失败: 截图分析深度不足。**

组件旅程截图中存在明确可见的异常信号，但 AI 全部漏掉了：

| # | 截图中可见的异常 | AI 的实际反应 | 正确反应 |
|---|------------------|---------------|----------|
| 1 | 在状态 2 编辑属性后，◆ 菱形标记未出现 | "值改了，继续" | "◆ 菱形标记应该出现但没有 → 停下追查" |
| 2 | 在状态 2 编辑属性后，"覆盖" badge 未出现 | 未注意 | "非默认状态应有橙色 badge → 异常" |
| 3 | Preview 循环两个状态无视觉变化 | "动画在播放" | "两个状态看起来一样 → override 可能为空" |
| 4 | 切回默认状态后被修改的值没恢复 | 未执行此检查 | "应该自动恢复 → 可能改了基础值" |

**问题不是"截图无法区分"，而是"AI 没有检查应该检查的视觉信号"。**

叠加三个流程缺陷：

| # | 漏洞 | 原因 |
|---|------|------|
| A | **核心协议无预测步骤** | 只有"描述看到了什么"，没有"预期应该看到什么" → 无对比基准 |
| B | **无视觉信号检查表** | AI 不知道每种操作后应该检查哪些 UI 指标 |
| C | **能力图谱缺少 "component"** | 即使协议完善，零画像覆盖多 group 也是盲区 |

### 5. 为什么文档缺少 group 维度？

因为文档是在单 group 阶段写的。多 group 是后续增量引入的，文档未同步更新。
**根因: 新架构概念的引入未触发文档 + 代码 + 测试三位一体的完整更新。**

---

## 修复

| 文件 | 改动 |
|------|------|
| **新增** `composables/useActiveGroup.ts` | 统一 group 解析逻辑 |
| `PropertiesPanel.vue` | 使用 composable 替换 2 处硬编码 |
| `SelectionOverlay.vue` | 使用 composable 替换 2 处硬编码 |
| `useLayerInteraction.ts` | 使用 composable 替换 2 处硬编码 |
| `useKeyboard.ts` | 使用 composable 替换 1 处硬编码 |
| `CurvePanel.vue` | 使用 composable 替换 1 处硬编码 |
| `PreviewPanel.vue` | 使用 composable 替换 4 处硬编码 |
| `PatchNode.vue` | 使用 composable 替换 2 处硬编码 |
| `patch.ts` | 引入 canvas store 替换 2 处硬编码 |
| 3 个 Exporter | 保留 `stateGroups[0]`（导出主画面是正确语义），加注释 |

---

## 流程改进 (按影响力排序)

### 改进 1 [P0]: 核心协议重写为"预测→观察→比对→质疑"

旧协议:
```
b. 描述截图中看到了什么 (具体画面内容)
```

新协议:
```
b. 预测: 执行后画面应该变成什么样？列出具体的视觉预期
c. curl 执行 → Read 截图
d. 比对: 逐项检查截图是否符合预期 (三问: 正信号/负信号/因果一致性)
e. 质疑: 有任何"不对"的感觉 → 停下来追查
```

**这是最关键的改进。** 从"被动描述"变为"主动断言"。

### 改进 2 [P0]: 每种操作配套视觉信号检查表

| 操作 | 必须出现 | 不该出现 |
|------|---------|---------|
| 编辑非默认状态属性 | ◆ 菱形 + "覆盖" badge + ↺ 重置按钮 | 无这三个标记 = bug |
| 切换状态 | 新标签高亮 + 属性值更新 | 旧标签仍高亮 = bug |
| 切换 group | group pill 高亮切换 + 状态列表更新 | 无变化 = bug |
| Preview 循环 | 两状态间有视觉差异 | 完全无差异 = override 可能为空 |
| 创建组件 | 画布新行 + 状态栏 group pill | 无新行 = 创建失败 |

AI 在每步截图检查时对照此表，而不是自由发挥。

### 改进 3 [P1]: 能力图谱增加 "component" 节点

```
能力图谱:
  states ─────┬── curves ──┐
              ├── patch ───┴── folme
              └── component
```

新增画像: {states, component} 等。所有组件场景自动获得旅程覆盖。

### 改进 4 [P1]: 旅程增加因果验证步骤

关键操作后，增加"反向验证":
- 在状态 2 修改属性后 → **切回状态 1 检查值是否恢复**
- 创建组件后 → **切换 group 检查数据隔离**
- 保存/导出后 → **用 evaluate 检查数据结构**

### 改进 5 [P2]: RELAY.md + Flow F 增加架构不变量

状态感知警告增加 group 维度；提交前检查 `grep stateGroups[0]`。

---

## 教训

### 教训 1: "看到了"不等于"验证了"

> AI 看截图时只做了"描述"（看到了 Y=50），没做"断言"（◆ 菱形标记应该出现但没出现）。
> 被动描述是旅程验证的最大陷阱 — 你会以为自己在验证，实际只是在走过场。

### 教训 2: 视觉信号是功能正确性的代理指标

> 每个 UI 指标（badge、菱形、高亮）都对应一个底层逻辑。
> 指标缺失 = 逻辑错误。AI 必须像测试工程师一样检查每个预期信号。

### 教训 3: 半迁移比不迁移更危险

> UI 层跑在新概念上，逻辑层还在旧假设上，
> 而用户看到的 UI 暗示一切正常。

架构新概念的引入必须触发:
1. **全量搜索** — `grep` 所有旧假设（如 `stateGroups[0]`）
2. **文档更新** — 核心概念速记、状态感知警告
3. **测试覆盖** — 新能力加入图谱，自动生成画像
4. **旅程断言** — 每步截图做"预测→比对"，不是"看一眼继续"
